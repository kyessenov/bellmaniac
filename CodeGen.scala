trait PythonPrinter {
  def prelude: String
  def print(s: Seq): String = s match {
    case Singleton(e) => "[" + print(e) + "]"
    case Join(l, r) => print(l) + " + " + print(r)
    case Compr(e, v, Range(l, h)) => "[" + print(e) + " for " + print(v) + 
      " in xrange(" + print(l) + ", " + print(h) + ")]"
  }
  def print(e: Expr): String = e match {
    case Var(n, _) => n
    case Const(i) => if (i >= 0) i.toString else "(-" + (-i).toString + ")"
    case Plus(l, r) => "(" + print(l) + " + " + print(r) + ")"
    case Minus(l, r) => "(" + print(l) + " - " + print(r) + ")"
    case Times(l, r) => print(l) + "*" + print(r)
    case Div(l, r) => print(l) + "/" + print(r)
    case Mod(l, r) => "(" + print(l) + " mod " + print(r) + ")"
    case App(v, args) => print(v) + "(" + args.map(print(_)).mkString(", ") + ")"
    case Op(l, r) => "plus(" + print(l) + ", " + print(r) + ")"
    case Reduce(r) => "reduce(plus, " + print(r) + ", zero)"
    case Zero => "zero"
    case Havoc => "random.randint(0, 1000)"
    case OpVar(v, args, exprs) => "(lambda " + args.map(print(_)).mkString(", ") + 
      ": " + print(v) + "(" + exprs.map(print(_)).mkString(", ") + "))"
    case Cond(cases, default) => cases match {
      case (pred, expr) :: rest => "(" + print(expr) + " if " + print(pred) + " else " + (rest match {
          case Nil => print(default)
          case _ => print(Cond(rest, default))
        }) + ")"
      case _ => ???
    }  
  }
  def print(p: Pred): String = p match {
    case True => "True"
    case False => "False"
    case And(l, r) => "(" + print(l) + " and " + print(r) + ")"
    case Or(l, r) => "(" + print(l) + " or " + print(r) + ")"
    case Not(l) => "(not " + print(l) + ")"
    case Eq(l, r) => "(" + print(l) + " == " + print(r) + ")"
    case LT(l, r) => "(" + print(l) + " < " + print(r) + ")"
    case GT(l, r) => "(" + print(l) + " > " + print(r) + ")"
    case LE(l, r) => "(" + print(l) + " <= " + print(r) + ")"
    case GE(l, r) => "(" + print(l) + " >= " + print(r) + ")"
  }
  def print(c: Computation): String
  def print(p: List[Computation], out: java.io.PrintStream) {
    out.println(prelude)
    for (c <- p)
      out.println(print(c))
  }
}

// Functional style code output
object Python extends PythonPrinter {
  override val prelude = 
"""class memoize(dict):
  def __init__(self, func):
    self.func = func
  def __call__(self, *args):
    return self[args]
  def __missing__(self, key):
    result = self[key] = self.func(*key)
    return result
plus = min
zero = pow(10, 16)
import random
import sys
sys.setrecursionlimit(2 ** 16)
"""
  def print(c: Computation): String = c match {
    case a: Algorithm =>
      "def " + print(a.v) +
      "(" + a.args.map(print(_)).mkString(", ") + "):\n" +     
      "  assert " + print(a.pre) + 
      "\n" + { a.expr match {
        case Cond(cases, default) => "  if " + cases.map { case (pred, expr) => 
          print(pred) + ":\n    return " + print(expr) }.mkString("\n  elif ") + 
          "\n  else:\n    return " + print(default)        
        case e => "  return " + print(e)
      }}
    case Input(v, e) => 
      if (v.arity == 0)
        print(v) + " = " + print(e) 
      else 
        "@memoize\ndef " + print(v) + "(" + 
          (1 to v.arity).map("v"+_).mkString(", ") + "):\n" +
        "  return " + print(e)
  }
}

// Imperative style code output
// Turn functions into NumPy tables
// Treat first 'dom' arguments as indexes into tables
// Expects input programs to be flattened
class NumPython(smt: Proof, val dom: Int) extends PythonPrinter with Logger {
  assert (dom > 0)
  
  def prelude = """# autogenerated by bellmaniac
import sys
plus = min
zero = sys.maxint
DIM = 128
MIN = 0
MAX = 1000
from numpy import *
""" 
 
  private def print(l: List[Expr]): String = l.map(print(_)).mkString(", ")  
  private def indent(tabs: Int = dom+1) = (1 to tabs).map(_ => "  ").mkString("")

  import Transform.{transform, visit}
  import scala.language.postfixOps
  import scala.language.implicitConversions

  // create T value
  val T = Var("T", dom)

  // current algorithm
  private var scope: Algorithm = _ 
  private var offv: List[Var] = _

  // all computations
  private var all: List[Computation] = _  
  
  def inputs = all.collect { case i: Input => i }
  def algorithms = all.collect { case a: Algorithm => a }

  // Use lookup tables instead of function applications 
  override def print(e: Expr) = e match {
    case App(v: Var, args) => print(v) + "[" + print(args) + "]"
    case _: OpVar => error("should be unreachable")
    case v: Var if v.arity > 0 =>
      if (inputs.exists(_.v == v) || scope.args.contains(v) || v.name.startsWith("T"))
        v.name
      else {
        // TODO: fix this
        // error("can only pass tables as parameters: " + v)    
        v.name
      }
        
    case _ => super.print(e)
  }

  // Write to T at offset off by invoking v with rest
  case class Write(v: Var, T: Var, off: List[Expr], rest: List[Expr], deps: List[Write]) {
    assert (v.arity == off.size + rest.size, "must match arity")
    assert (off.size == dom && T.arity == dom)

    override def toString = v.name + "("  + print(T :: off ::: rest) + ")"

    def all: List[Write] =
      deps.flatMap(_.all) ::: this :: Nil

    def stmts: List[String] = all.map(_.toString)

    // same up to renaming of all Ts and this.off
    def same(that: Write): Boolean =
      this.v == that.v &&
      (this.rest zip that.rest).forall {
        case (e1, e2) =>
          e1 == e2 ||
          ((this.deps.find(_.T == e1), that.deps.find(_.T == e2)) match {
            case (Some(w1), Some(w2)) if w1.off == w2.off =>
              w1.same(w2)              
            case _ => false
          })
      }

    def replace(implicit that: Write): Write = {
      deps.find { case w => w.same(that) } match {
        case Some(w) => // replace and repeat
          // offset corrections 
          val offsets = that.off zip w.off map Minus.tupled;
          
          copy(deps = deps.filter(_ != w),
               rest = transform(App(v, off ::: rest)) {
                  case App(v, args) if args.contains(w.T) => 
                    // add offsets according to position of w.T
                    val a = algorithms.find(_.v == v).get
                    // find additions
                    var add: Map[Var, Expr] = Map()
                    for ((formal, actual) <- a.args zip args;
                         if actual == w.T;
                         (o, i) <- offsets.zipWithIndex)
                       add = add + (Var(formal.name + "_" + i) -> o)
                    // add them
                    App(v, for ((formal, actual) <- a.args zip args) yield {
                        if (actual == w.T)
                          that.T
                        else if (add.contains(formal))
                          Linear.make(actual + add(formal)).expr
                        else 
                          actual
                    })
                  case v: Var if v == w.T =>
                    error("must appear as a parameter in App")
                } match {
                  case App(_, args) => args.drop(dom)
                  case _ => ???
                }
          ).replace
        case None => // recurse
          copy(deps = deps.map(_.replace))
      }
    }
 }

  object Write {
    // top-level write
    def make(app: App): Write =
      make(app, T, offv zip scope.args.take(dom) map Plus.tupled)

    // off is compared to first arguments of app for offsets
    // outputs list of write with last corresponding to this "app"
    // each child T is used only once in the parent
    def make(app: App, T: Var, off: List[Expr]): Write = app match {
      case App(v: Var, args) =>
        val offsets = 
          for ((o, a) <- off zip args.take(dom))
            yield Linear.make(o - a).expr
             
        var deps: List[Write] = Nil 

        // recurse on dependency OpVars
        val rest = for (arg <- args.drop(dom)) yield transform(arg) {
          case OpVar(v, args, exprs) =>
            assert(v.isInstanceOf[Var], "must be flattened")
            assert(exprs.startsWith(args), "must be fully linearized")
            //assert(args.size == dom, "must match dom")            
            val T1 = T.fresh
            // todo: extract offsets from the opvar
            // deps = make(App(v, exprs), T1, args) :: deps

            // XXX: hack below
            deps = make(App(v, exprs), T1, args ::: exprs.take(dom - args.size)) :: deps
            T1
        }
        
        Write(v, T, offsets, rest, deps.reverse) 
    }
  }

 
  
  // use partitions in other partitions writes
  def reuse(writes: List[Write]) = {
    var deps: List[(Int, Int)] = Nil

    def replaceAll(writes: List[Write]) = 
      for ((w1,i) <- writes.zipWithIndex) yield {
        var out = w1
        for ((w2,j) <- writes.zipWithIndex if i != j) {          
          val next = out.replace(w2)
          if (out != next) {        
            out = next
            deps = (j, i) :: deps
          }
        }
        out            
      }

    var result: List[Write] = writes
    var prev: List[Write] = Nil
    while (result != prev) {
      prev = result
      result = replaceAll(result)
    }

    // permute according to deps
    def order(g: List[Int]): List[Int] = g match {
      case Nil => Nil
      case _ =>
        // find node without incoming edges
        g.find { case i => ! deps.exists(_._2 == i) } match {
          case Some(i) =>
            // remove from graph and recurse
            deps = deps.filter(_._1 != i)
            i :: order(g.filter(_ != i))
          case _ => error("loop detected")
        }
    }    

    order(0 to (writes.size - 1) toList).map(result(_))
  }

  // TODO: unsound
  // reuse memory tables in a write sequence 
  def overwrite(w: Write): Write = w match {
    case Write(v, t, off, rest, List(w1)) => 
      // must use only one temporary table once
      val t1 = w1.T
      if (! w1.off.forall(_ == Const(0)))
        error("must have 0-based tables")

      // must write where it reads from
      var off1: List[Expr] = Nil

      // find where it's used
      val rest1 = transform(App(v, off ::: rest)) {
        case App(v, args) if args.contains(t1) => 
          val a = algorithms.find(_.v == v).get
          
          // find formal argument for t1
          val formal = (a.args zip args).filter(_._2 == t1).map(_._1) match {
            case f :: Nil => f
            case _ => error("must have exactly one argument " + t1)
          }

          // find read signatures for a
          val fc = memory(a).read.filter(_.v == formal).map(_.c) match {
            case fc :: Nil => fc.map(_.s(a.args zip args))
            case _ => error("must have exactly one read vector " + t1)
          }

          // read at off1 from invocation point
          off1 = (0 to (dom-1)).map(i => 
            Linear.make(off(i) + args(i) - fc(i)).expr).toList

          // correcte offsets to use t instead of t1:
          var add = {for (i <- (0 to (dom - 1)))
            yield (Var(formal.name + "_" + i), off1(i))
          }.toMap

          // reuse this t in place of t1
          App(v, a.args zip args map {
            case (f, a) if f == formal => t
            case (f, a) if add.contains(f) => Linear.make(a + add(f)).expr
            case (_, a) => a
          })
        case v: Var if v == t1 =>
          error("must appear as a parameter in App")
      } match {
        case a: App => a.args.drop(dom)
        case _ => error("unexpected")
      }

      Write(v, t, off, rest1, List(overwrite(w1.copy(T = t, off = off1))))      
    case _ => w 
  }

  override def print(c: Computation) = c match {
    case Input(v, e) =>
      print(v) + " = " + (e match {
        case Havoc if v.arity > 0 =>
          "random.randint(MIN, MAX, size=(" + (1 to v.arity).map(_ => "DIM").mkString(", ") + "))"
        case e if v.arity == 0 =>
           print(e)
        case e if v.arity > 0 =>
          "empty((" + (1 to v.arity).map(_ => "DIM").mkString(", ") + "), int)\n" + 
          print(v) +".fill(" + print(e) +")"
      })
    case a @ Algorithm(v, args, pre, e) =>        
      this.scope = a
      this.offv = args.take(dom).map { case Var(n, i) => Var("o" + n, i) }
      val loop = new LoopConstruct(a)

      "def " + v.name + "(" + print(T :: offv ::: args.drop(dom)) + "):\n" + {
        e match {
          case Cond(cases, Havoc) if cases.forall(_._2.isInstanceOf[App]) =>
            // SPLIT PROGRAM
            // compute with write sequences
            cases match {
              case (minp, mine: App) :: splits =>
                val (preds, es) = splits.unzip
                val apps = es.map {
                  case app: App => app
                  case _ => error("expected an app here")
                }
                // double check that splits are coming from the tactic
                for (p1 <- preds; p2 <- preds; if p1 != p2)
                  assert(smt.prove((pre and p1) implies (! p2)))

                // reuse and overwrite
                val writes = reuse(apps.map(Write.make(_))).map(overwrite(_))
                
                "  if " + print(minp) + ":\n    " + 
                Write.make(mine).stmts.mkString("\n    ") + 
                "\n    return\n  " + {
                  (for (w1 <- writes;
                        w <- w1.all if w.T != T;
                        a <- algorithms if a.v == w.v)
                    yield print(w.T) + " = " + memory(a).alloc) :::
                  (for (w <- writes; stmt <- "# partition" :: w.stmts)
                    yield stmt)
              }.mkString("\n  ")
              case _ => ???
            }

          case _ =>
            // ABSTRACT SPEC PROGRAM
            // compute with the loop construct
            val (lvars, lbounds, lmap) = loop.generate

            // must be self-recursive for this to work
            def makeTs(e: Expr): Expr = transform(e) {
              case App(v, args) if a.v == v =>
                if (args.drop(dom) == a.args.drop(dom))
                  App(T, args.take(dom).map(makeTs) zip offv map { case (a, o) => a + o })
                else
                  error("self-recursion must project to same value")
            }
 
            {for (((lv, Range(l, h)), i) <- lvars zip lbounds zipWithIndex) 
              yield indent(i+1) + "for "+print(lv)+" in xrange("+print(l)+","+print(h)+"):\n"
            }.mkString("") + 
            {for ((l,i) <- lmap zipWithIndex) 
              yield indent() + args(i)+" = "+lmap(i)+"\n"
            }.mkString("") +
            indent() + "assert " + print(pre) + "\n" +   
            indent() + print(makeTs(App(v, args))) + " = " + print(makeTs(e))
        }
      }
  }
 
  override def print(p: List[Computation], out: java.io.PrintStream) {
    this.all = p
    super.print(p, out)
  }

  // Generate loop construct for an algorithm
  // Additional references:
  //    polyhedral model on wiki
  //    Omega library tutorials (e.g. SUIF)

  case class Rotation(flips: List[Boolean]) {  
    def apply(a: List[Expr]) = a zip flips map { 
      case (x, false) => x
      case (x, true) => Const(0) - x
    }
    def inverse = this
  }
  object Rotation {
    def all(d: Int): Iterator[Rotation] =   
      if (d == 0)
        List(Rotation(Nil)).iterator
      else
        (all(d-1) map { case Rotation(flips) => Rotation(false :: flips) }) ++
        (all(d-1) map { case Rotation(flips) => Rotation(true :: flips) })
  }

  case class Vector(path: Pred, v: Var, c: List[Expr]) 

  class LoopConstruct(a: Algorithm) extends Logger {
    val pre = a.pre
    val c = a.args.take(dom)
    
    // find all recursion references
    def vectors = {
      var out: List[Vector] = Nil
      transform(a) {
        case (path, locals, App(v, vargs)) =>
          if (v == a.v)
            out = Vector(path, a.v, vargs.take(dom)) :: out
          else if (! locals.contains(v) && ! inputs.exists(_.v == v))
            error("unexpected: " + v + " in " + a.v)
          Havoc
      }
      out
    }

    // domination order
    def lexorder(a: List[Expr], b: List[Expr]): Pred = (a, b) match {
      case (Nil, Nil) => True
      case (a0 :: a1, b0 :: b1) => a0 < b0 or (a0 === b0 and lexorder(a1, b1))
      case _ => ???
    }
    
    // find domination order orientation
    def orient(vs: List[Vector]): (Rotation, List[Int]) = {
      for (p <- (0 to dom-1).toList.permutations;
           r <- Rotation.all(dom))
        if (vs.forall { case Vector(path, _, vc) => 
          smt.prove(path implies lexorder(p.map(r(vc)(_)), p.map(r(c)(_)))) 
        })
          return (r, p)
      error("can't orient in domination order: " + vs.mkString(", "))    
    }
    implicit def int2rat(n: Int) = new Rational(n, 1)
    implicit def int2expr(n: Int) = Const(n)
    implicit def int2linear(n: Int) = Linear.make(Map(), new Rational(n, 1))

    // solve for max expression
    def MAX(p: List[Expr], pred: Pred): Expr = p match {
      case Nil => ???
      case e :: Nil => e
      case e :: p1 =>
        val e1 = MAX(p1, pred)
        if (smt.prove(pred implies e1 <= e))
          e
        else if (smt.prove(pred implies e <= e1))
          e1
        else 
          error("can't find max of " + p + " under " + pred)        
    }

    // solve for min expression
    def MIN(p: List[Expr], pred: Pred): Expr = p match {
      case Nil => ???
      case e :: Nil => e
      case e :: p1 =>
        val e1 = MIN(p1, pred)
        if (smt.prove(pred implies e <= e1))
          e
        else if (smt.prove(pred implies e1 <= e))
          e1
        else 
          error("can't find min of " + p + " under " + pred)        
    }

    // Infer range constraints from linear constraints in predicate
    def inferBounds(p: List[Var], pred: Pred, 
      use: Boolean = true, transitive: Boolean = false): Option[List[Range]] = {
      var eqs = Linear.equations(pred)

      // compute transitive equations by eliminating one variable at a time
      if (transitive) 
        eqs = eqs ::: {
          for (v <- p;
            e1 <- eqs if e1.proj(v) > 0;
            e2 <- eqs if e2.proj(v) < 0) yield 
            e1 * e2.proj(v) * (-1) + e2 * e1.proj(v)         
          }
      

      // free variables (allowed to appear in result range)
      var free = Transform.vars(pred) -- p
      
      var out: List[Range] = Nil
      for (v <- p) {       
        // find constraints only contains "free" vars and having "v"
        val bounds = eqs.filter { case eq => eq.has(v) && eq.vars.subsetOf(free + v) }
      
        // upper and lower bound expressions
        val lower = bounds.filter(_.proj(v) > 0).map { 
          case eq => 0 - (eq.drop(v) / eq.proj(v)) }.map(_.expr)
        val upper = bounds.filter(_.proj(v) < 0).map { 
          case eq => 1 - (eq.drop(v) / eq.proj(v)) }.map(_.expr)

        if (lower.size == 0 || upper.size == 0)
          return None

        // use previous variables in generating subsequent range bound
        if (use)
          free = free + v

        out = Range(MAX(lower, pred), MIN(upper, pred)) :: out
      }

      return Some(out.reverse)
    }


    // generate looping construct for first "dom" parameters of "a"
    // returns (list of iteration variables, list of their ranges, assignment to actual variables)
    def generate: (List[Var], List[Range], List[Expr]) = {
      // orient dependency vectors by flipping +/- coordinates so that they point
      // into lower-left corner in the lexicographic order
      // p applied after r
      val (r, p) = orient(vectors)

      // find iteration order and bounds
      // create fresh variables: c1 = r(c)
      val c1 = c.map { case Var(n, i) => Var(n +"0", i) }
      
      // formulate pre in terms of c1
      val exprs = r.inverse(c1)
      val pre1 = pre.s(c zip exprs)

      // solve for bounds
      val p1 = p.map(c1(_))
      inferBounds(p1, pre1) match {
        case Some(ranges) => (p1, ranges, exprs)
        case _ => error("can't infer bounds: " + pre1)
      }
    }
  }

  // Specifies read/write ranges 
  // (reads are applications of arguments under path conditions for given x in DOM)
  // (writes are bounds on DOM)
  // In particular, we can write into tables used in read as long as it's same x
  class MemorySpec(a: Algorithm) {
    // table dimensions (range from 0 to Expr)
    def write: List[Expr] = new LoopConstruct(a).inferBounds(a.args.take(dom), a.pre, false, true) match {
      case Some(ranges) =>
        for (Range(l, h) <- ranges) yield {
          if (! smt.prove(a.pre implies l >= Const(0)))
            error("can't allocate memory with possibly negative index")
          h
        }
      case None => 
        error("can't infer memory allocation bounds")
    }

    def alloc = "zeros((" + print(write) + "), int)"
    
    def read: List[Vector] = {
      var out: List[Vector] = Nil      
      transform(a) {
        case (path, _, App(v: Var, vargs)) if a.args.contains(v) && v.arity == dom =>
          out = Vector(path, v, vargs) :: out
          Havoc
        case (_, _, App(v, _)) if v == a.v =>
          // TODO: block recursive passes of arguments, need to think about why it's ok
          Havoc
        case (_, _, v) if a.args.contains(v) && v.arity == dom =>
          println(a)
          error(s"can't infer memory spec if an argument function $v is passed in a call in ${a.v}")
      }
      out
    }
  }

  // use specification memory spec for an algorithm
  def memory(a: Algorithm): MemorySpec = a.expr match {
    case Cond((_, App(v, _)) :: _, Havoc) => // split?
      memory(algorithms.find(_.v == v).get)
    case _ => new MemorySpec(a)  
  }
}
